#include <iostream>
#include <cmath>
#include <stack>
#include <vector>
#include <cstring>
#include <fstream>
#include "tgaimage.h"

using namespace std;

const TGAColor black = TGAColor(0, 0, 0, 0);
const TGAColor white = TGAColor(255, 255, 255, 255);
const TGAColor red = TGAColor(255, 0, 0, 255);

void line(int x1, int y1, int x2, int y2, TGAImage &image, TGAColor color) //Alg_Brez modif+
{
	int deltaX = abs(x2 - x1);
	int deltaY = abs(y2 - y1);
	int signX = x1 < x2 ? 1 : -1;
	int signY = y1 < y2 ? 1 : -1;
	int error = deltaX - deltaY;
	image.set(x2, y2, color);
	while (x1 != x2 || y1 != y2)
	{
		image.set(x1, y1, color);
		if (error * 2 > -deltaY)
		{
			error -= deltaY;
			x1 += signX;
			continue;
		}
		if (error * 2 < deltaX)
		{
			error += deltaX;
			y1 += signY;
			continue;
		}
	}
}

struct Pixel
{
	int x = 0, y = 0;
};

struct otrezok
{
	int x1 = 0, y1 = 0, x2 = 0, y2 = 0;
};

otrezok rebro(int x1, int y1, int x2, int y2)
{
	otrezok o;
	o.x1 = x1;
	o.x2 = x2;
	o.y1 = y1;
	o.y2 = y2;
	return o;
}


void zalivka_postrochno(otrezok R1, otrezok R2, otrezok R3, TGAImage &image, TGAColor color)
{
	vector <Pixel> list1;
	Pixel Z;
	if (R1.y2 != R1.y1 && R1.x2 != R1.x1)
	{
		int signX = R1.x1 < R1.x2 ? 1 : -1;
		int signY = R1.y1 < R1.y2 ? 1 : -1;
		double x = R1.x1, y = R1.y1, delta = (double)abs(R1.x2 - R1.x1) / (double)abs(R1.y2 - R1.y1);
		while (y != R1.y2)
		{
			Z.x = (int)x, Z.y = (int)y;
			list1.push_back(Z);
			x += signX*delta, y += signY;
		}
	}
	else
	{
		Z.x = R1.x1, Z.y = R1.y1;
		list1.push_back(Z);
		Z.x = R1.x2, Z.y = R1.y2;
		list1.push_back(Z);
	}

	vector <Pixel> list2;
	if (R2.y2 != R2.y1 && R2.x2 != R2.x1)
	{
		int signX = R2.x1 < R2.x2 ? 1 : -1;
		int signY = R2.y1 < R2.y2 ? 1 : -1;
		double x = R2.x1, y = R2.y1, delta = (double)abs(R2.x2 - R2.x1) / (double)abs(R2.y2 - R2.y1);
		while (y != R2.y2)
		{
			Z.x = (int)x, Z.y = (int)y;
			list2.push_back(Z);
			x += signX*delta, y += signY;
		}
	}
	else
	{
		Z.x = R2.x1, Z.y = R2.y1;
		list2.push_back(Z);
		Z.x = R2.x2, Z.y = R2.y2;
		list2.push_back(Z);
	}

	vector <Pixel> list3;
	if (R3.y2 != R3.y1 && R3.x2 != R3.x1)
	{
		int signX = R3.x1 < R3.x2 ? 1 : -1;
		int signY = R3.y1 < R3.y2 ? 1 : -1;
		double x = R3.x1, y = R3.y1, delta = (double)abs(R3.x2 - R3.x1) / (double)abs(R3.y2 - R3.y1);
		while (y != R3.y2)
		{
			Z.x = (int)x, Z.y = (int)y;
			list3.push_back(Z);
			x += signX*delta, y += signY;
		}
	}
	else
	{
		Z.x = R3.x1, Z.y = R3.y1;
		list3.push_back(Z);
		Z.x = R3.x2, Z.y = R3.y2;
		list3.push_back(Z);
	}

	vector<Pixel> fulllist;
	fulllist.insert(fulllist.end(), list1.begin(), list1.end());
	fulllist.insert(fulllist.end(), list2.begin(), list2.end());
	fulllist.insert(fulllist.end(), list3.begin(), list3.end());

	for (int i = 1; i < fulllist.size(); i++)
		for (int j = 0; j < fulllist.size() - i; j++)
			if (fulllist[j].y > fulllist[j + 1].y)
				swap(fulllist[j], fulllist[j + 1]);

	for (int i = 1; i < fulllist.size(); i++)
		for (int j = 0; j < fulllist.size() - i; j++)
			if (fulllist[j].y == fulllist[j + 1].y && fulllist[j].x > fulllist[j + 1].x)
				swap(fulllist[j], fulllist[j + 1]);

	Pixel Point1, Point2;
	while (!fulllist.empty())
	{
		Point1 = fulllist.back();
		fulllist.pop_back();
		if (!fulllist.empty())
		{
			Point2 = fulllist.back(), fulllist.pop_back();
			line(Point1.x, Point1.y, Point2.x, Point2.y, image, color);
		}
		else
			image.set(Point1.x, Point1.y, color);
	}
}

struct fstring
{
	int a, b, c;
};

int main()
{
	TGAImage image(3000, 3000, TGAImage::RGB);
	double r = 0;
	ifstream in;
	char str[255];
	char *p, *context1, *context2, *v1, *v2, *v3, *f1, *f2, *f3;
	double a1 = 0, a2 = 0, a3 = 0;
	int b1 = 0, b2 = 0, b3 = 0;
	in.open("african_head.obj");
	int k = 0;
	while (!(in.eof()))
	{
		in.getline(str, 255);
		if (str[0] == 'v') k++;
	}
	in.close();
	int** arrk = new int*[k];
	for (int i = 0; i < k; i++)
		arrk[i] = new int[4];
	for (int i = 0; i < k; i++)
		for (int j = 0; j < 4; j++)
			arrk[i][j] = 0;
	in.open("african_head.obj");
	int l = 0;
	while (!(in.eof()))
	{
		in.getline(str, 255);
		if (str[0] == 'f') l++;
	}
	in.close();
	fstring ** arrl = new fstring*[l];
	for (int i = 0; i < l; i++)
		arrl[i] = new fstring[3];
	for (int i = 0; i < l; i++)
		for (int j = 0; j < 3; j++)
			arrl[i][j].a = 0, arrl[i][j].b = 0, arrl[i][j].c = 0;
	in.open("african_head.obj");

	int i = 0;
	while (!(in.eof()))
	{
		in.getline(str, 255);
		if (str[0] == 'v')
		{
			p = strtok_s(str, " ", &context1);
			v1 = strtok_s(NULL, " ", &context1);
			v2 = strtok_s(NULL, " ", &context1);
			v3 = strtok_s(NULL, " ", &context1);
			a1 = atof(v1), a2 = atof(v2), a3 = atof(v3);
			arrk[i][0] = int(a1 / (r * a3 + 1) * 1500), arrk[i][1] = int(a2 / (r * a3 + 1) * 1500), arrk[i][2] = int(a3 / (r * a3 + 1) * 1500);
			arrk[i][3] = 1;
			i++;
		}
	}

	in.close();
	in.open("african_head.obj");
	int j = 0;
	while (!(in.eof()))
	{
		in.getline(str, 255);
		if (str[0] == 'f')
		{
			p = strtok_s(str, " ", &context1);
			f1 = strtok_s(NULL, " ", &context1);
			f2 = strtok_s(NULL, " ", &context1);
			f3 = strtok_s(NULL, " ", &context1);

			b1 = atoi(strtok_s(f1, "/", &context2));
			arrl[j][0].a = b1;
			b1 = atoi(strtok_s(NULL, "/", &context2));
			arrl[j][0].b = b1;
			b1 = atoi(strtok_s(NULL, "/", &context2));
			arrl[j][0].c = b1;

			b2 = atoi(strtok_s(f2, "/", &context2));
			arrl[j][1].a = b2;
			b1 = atoi(strtok_s(NULL, "/", &context2));
			arrl[j][1].b = b2;
			b1 = atoi(strtok_s(NULL, "/", &context2));
			arrl[j][1].c = b2;

			b3 = atoi(strtok_s(f3, "/", &context2));
			arrl[j][2].a = b3;
			b1 = atoi(strtok_s(NULL, "/", &context2));
			arrl[j][2].b = b3;
			b1 = atoi(strtok_s(NULL, "/", &context2));
			arrl[j][2].c = b3;
			j++;
		}
	}
	in.close();

	for (int i = 0; i < l; i++)
	{
		int p1 = arrl[i][0].a - 1, p2 = arrl[i][1].a - 1, p3 = arrl[i][2].a - 1;
		int xA = arrk[p1][0] + 1500, yA = arrk[p1][1] + 1500, zA = arrk[p1][2];
		int xB = arrk[p2][0] + 1500, yB = arrk[p2][1] + 1500, zB = arrk[p2][2];
		int xC = arrk[p3][0] + 1500, yC = arrk[p3][1] + 1500, zC = arrk[p3][2];
		int zN = ((xB - xA - 3000)*(yC - yB - 3000) - (xC - xB - 3000)*(yB - yA - 3000)) * 1500 / sqrt (pow(((yB - yA - 3000)*(zC - zB - 3000) - (yC - yB - 3000)*(zB - zA - 3000)), 2) + pow((- (xB - xA - 3000)*(zC - zB - 3000) + (xC - xB - 3000)*(zB - zA - 3000)), 2) + pow(((xB - xA - 3000)*(yC - yB - 3000) - (xC - xB - 3000)*(yB - yA - 3000)), 2));
		int k = (double)(zN * 255 / 1500) + 100;
		if (k < 0) k = 0;
		if (k > 255) k = 255;
		cout << k << " ";

		otrezok R1, R2, R3;
		R1 = rebro(xA, yA, xB, yB);
		R2 = rebro(xB, yB, xC, yC);
		R3 = rebro(xC, yC, xA, yA);

		line(R1.x1, R1.y1, R1.x2, R1.y2, image, white);
		line(R2.x1, R2.y1, R2.x2, R2.y2, image, white);
		line(R3.x1, R3.y1, R3.x2, R3.y2, image, white);

		zalivka_postrochno(R1, R2, R3, image, TGAColor(k, k, k, 255));
		cout << "wait..." << i << "/"<< l << endl;
	}

	image.flip_vertically();
	image.write_tga_file("output.tga");

	for (int i = 0; i < k; i++)
		delete[] arrk[i];
	delete[] arrk;
	for (int i = 0; i < l; i++)
		delete[] arrl[i];
	delete[] arrl;

	//system("pause");
	return 0;
}
